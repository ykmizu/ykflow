



#include "yk_XFlow.h"

//-----------------------------------------------------------------------------
// Calls the xflow solver. ykflow solver inherits the xflow specific functions
//-----------------------------------------------------------------------------
yk_PrimalSolver* new_Xflow(){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  yk_Xflow * xflow = (yk_Xflow *) malloc (sizeof(yk_Xflow));
  yk_PrimalSolver* ykflow = new_Ykflow();
  ykflow->solver = xflow;
  xflow->ykflow = ykflow;
  /* ykflow->Function = yk_xflow_function; */
  /* ykflow->dFunctiondu = yk_xflow_dfunctiondu; */
  ykflow->Residual = yk_xflow_totalResidual;
  ykflow->FomName = yk_fomBuffer;
  ykflow->boundarySeeds = yk_findBoundarySeeds;
  /* ykflow->adjacentElems = yk_findAdjacentElems; */
  /* ykflow->aveSpatialOutput = yk_uploadStateCalcSpatialAverageOutput; */
  /* ykflow->spatialdJdU = yk_uploadStateCalcSpatialdJdU; */
  /* ykflow->multiplyByInvMass = yk_MultInvMassMatrixArray; */
  /* ykflow->injectH2h = yk_inject; */
  /* ykflow->anyFunction = yk_anyArrayFunction; */
  ykflow->delete = delete_Xflow;
  return ykflow;
}

void delete_Xflow(yk_PrimalSolver *ykflow){
  free(ykflow->solver);
  free(ykflow);

}

void yk_findBoundarySeeds(yk_PrimalSolver *ykflow, Multiverse* multiquation,
                          Cluster *primal, int nSampNodes, int *numSeeds,
                          int *nodeSet){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i, j, k;                          //initialization for iteration
  int count = 0;                        //will give me total # of elems
  int elem;                             //saves the current element to add
  int numBFG;                           //total num of boundary group
  int numBasis = primal->self->basis.nodes;
  int elemSize = numBasis*multiquation->equation.numStates;
  yk_Xflow *xflow = (yk_Xflow *) ykflow->solver;
  xf_BFaceGroup *aBFG = xflow->All->Mesh->BFaceGroup;
  xf_ElemGroup *elemGroup = xflow->All->Mesh->ElemGroup;
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  numBFG = xflow->All->Mesh->nBFaceGroup; //total num of boundary group
  for (i=0; i<numBFG; i++){
    elem = 0;                         //set to 0, want global elem number
    j= aBFG[i].nBFace-1; //Just need one element on the boundary for each group
    for (k=0; k< aBFG[i].BFace[j].ElemGroup; k++) //elemgroup
      elem += elemGroup[k].nElem;     //find global number
    elem += aBFG[i].BFace[j].Elem;    //find actual elem value
    for (k=0; k<multiquation->equation.numStates; k++){
      //rate through total elem vec size
      //nodeSet[elemSize*count+k] = elemSize*elem+k; //node vector value
      nodeSet[multiquation->equation.numStates*count+k] =
        elemSize*elem+k;
      //nodeSet[elemSize*count] = elemSize*elem;
      //printf("%d\n", elemSize*count+k);
      // }
    }
    count++;                          //sums up tot number of elems thus far
  }
  if (nSampNodes <= count*multiquation->equation.numStates){
    //Verfiy there's enough sample nodes
    printf("Need to specify at least %d more nSampleNodes\n", count*
           multiquation->equation.numStates- nSampNodes);
    exit(EXIT_FAILURE);                 //quit if user needs to specify more
  }else
    *numSeeds = count*multiquation->equation.numStates;
}



//-----------------------------------------------------------------------------
//Convert the ykflow array format to xflow Vector format
//-----------------------------------------------------------------------------
void yk_array2Vector(xf_Vector *A, Galaxy *object){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i, j, k, n;                       // initialization for iteration
  int rOrd;                             // Num of  total basis nodes and states
  int count = 0;                        // Counter to save in correct indicies
  int numStates;                        // Number of totoal states in the sys
  xf_GenArray *genA;                    // shortcode to group array
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  for (i=0; i<A->nArray; i++){
    genA = A->GenArray + i;
    for (j=0; j<genA->n; j++){ //Iterate through number of elements
      rOrd = ((genA->vr == NULL) ? genA->r : genA->vr[j]);
      numStates = rOrd/object->basis.nodes;
      if (A->GenArray[i].rValue != NULL) // Only going to look at real values
        for (k=0; k<object->basis.nodes; k++)
          for (n=0; n<numStates; n++) //Save array values to xflow vectors
            A->GenArray[i].rValue[j][(k*numStates)+n]=
              object->solution[n].array[count+j*object->basis.nodes+k];
      //else if (A->GenArray[i].iValue != NULL)   //For int values
    }
    count += genA->n*object->basis.nodes;
  }
}
//-----------------------------------------------------------------------------
//Convert the ykflow array format to Vector Group
//-----------------------------------------------------------------------------
void yk_array2VectorGroup(xf_VectorGroup *A, Galaxy *pObj){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i;                                // Initialization for iteration
  for (i=0; i<A->nVector; i++)
    yk_array2Vector(A->Vector[i], pObj);
}


//-----------------------------------------------------------------------------
// Setting a Mat Petsc Object xflow matrix
//-----------------------------------------------------------------------------
void yk_matrix2D2MatGroup(xf_All *All, xf_JacobianMatrix *dRdU, Galaxy *pObj,
                          Mat matObj, Is_it *reduced){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i, j, k, m, n, p;                 // Initialization for iteration
  int groupN, elemN, faceN;             // Actual values relative to xflow
  int negrp = dRdU->negrpself;          // Total number of groups
  int nface;                            // number of faces for each element
  int nn, nnN;
  int sr = All->EqnSet->StateRank;
  int *egrpOffset;
  int globalIndex;
  int r, rN, row, col;
  int floorElem = 0;
  int globalElem, localElem;
  int *getMeshIndex = createMeshMap(&pObj->space);
  int nBasis = pObj->basis.nodes;
  real *A;
  Mesh _meshOfInterest;                 // Mesh of interest depending of ROM
  //---------------------------------------------------------------------------
  // Initialization
  //---------------------------------------------------------------------------
  if (reduced->hrom==1)
    _meshOfInterest = reduced->reducedMesh;
  else
    _meshOfInterest = pObj->space;
  // initialize the group offset values
  xf_Error(xf_Alloc( (void **) &egrpOffset, negrp, sizeof(int)));
  //---------------------------------------------------------------------------
  // Calculate the global index offsets since there are multiple groups
  //---------------------------------------------------------------------------
  globalIndex = 0;
  for (i=0; i<negrp; i++){              // Calculate global index offsets
    egrpOffset[i] = globalIndex;
    for (j=0; j<dRdU->nElem[i]; j++){
      nn = xf_Jacobian_n(dRdU, i, j);
      globalIndex += nn*sr;
    }
  }
  //---------------------------------------------------------------------------
  // Routine to convert ykflow 2D array to Mat values
  //---------------------------------------------------------------------------
  for (j=0; j<_meshOfInterest.elem.count; j++){
    floorElem = 0;
    globalElem = _meshOfInterest.elem.array[j]; //find the global elem
    for (i=0; i<negrp; i++){            // calculate local elem in itsgroup
      floorElem += dRdU->nElem[i];      // Helps with element local value
      if (globalElem <= floorElem-1){
        localElem = globalElem;
        if (i>0)
          for (m=0; m<i; m++)
            localElem -= dRdU->nElem[m];
        break;
      }
    }
    nface = dRdU->nFace[i][localElem];  //gets the total number of faces
    for (k=-1; k<nface; k++){           //iterate through the number of faces
      if (k == -1){                     //Itself information
        groupN = i;
        elemN = localElem;
        faceN = k;
      }else{
        groupN = dRdU->egrpN[i][localElem][k]; //Surrounding element group
        elemN = dRdU->elemN[i][localElem][k];  //Surrounding element elem
        faceN = dRdU->faceN[i][localElem][k];  //Surrounding element face
      }
      if (groupN < 0 )
        continue;               //If boundary element skip rest
      A = dRdU->Value[i][localElem][1+k]; //Extract the block matrix values
      nn = xf_Jacobian_n(dRdU, i, localElem); //# of unknowns
      r = sr*nn;
      nnN = xf_Jacobian_n(dRdU, groupN, elemN); //# of unknowns;
      rN = sr*nnN;
      row = 0;
      col = 0;
      floorElem = 0;
      for (m=0; m<groupN; m++)
        floorElem += dRdU->nElem[m];
      elemN +=floorElem;
      for (m = 0; m<j; m++)
        row +=sr*nBasis;
      for (m = 0; m<getMeshIndex[elemN]; m++)
        col +=sr*nBasis;
      for (m=0; m<nn; m++)
        for (n=0; n<nnN; n++)
          for (p=0; p<sr*sr; p++)
            if (A[(m*nnN+n)*sr*sr+p]!= 0.0)
              MatSetValue(matObj, row+m*sr+(p/sr), col+n*sr+(p%sr),
                          A[(m*nnN+n)*sr*sr+p], INSERT_VALUES);
    }
  }
  MatAssemblyBegin(matObj, MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(matObj, MAT_FINAL_ASSEMBLY);
  free(getMeshIndex);
  xf_Release(egrpOffset);
}
//-----------------------------------------------------------------------------
// Concert vector xflow format to Vec Petsc format
//-----------------------------------------------------------------------------
void yk_vector2Vec(xf_All *All, xf_Vector *A, Galaxy *pObj, Vec vecObj,
                   Is_it *reduced){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i, j, k, m;                          // initialization for iteration
  int rOrd;
  int globalElem;
  int localElem;
  int floorElem;
  xf_GenArray *genA;
  PetscScalar value;
  Mesh _meshOfInterest;
  //---------------------------------------------------------------------------
  // Initialization
  //---------------------------------------------------------------------------
  if (reduced->hrom==1)
    _meshOfInterest = reduced->reducedMesh;
  else
    _meshOfInterest = pObj->space;
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  for (j=0; j<_meshOfInterest.elem.count; j++){
    floorElem = 0;
    globalElem = _meshOfInterest.elem.array[j]; //find the global elem
    for (i=0; i<A->nArray; i++){            // calculate local elem in itsgroup
      genA = A->GenArray + i;
      floorElem += genA->n;      // Helps with element local value
      if (globalElem <= floorElem-1){
        localElem = globalElem;
        if (i>0)
          for (m=0; m<i; m++)
            localElem -= A->GenArray[m].n;
        break;
      }
    }
    rOrd = ((genA->vr == NULL) ? genA->r : genA->vr[localElem]);
    if (A->GenArray[i].rValue != NULL){
      for (k=0; k<rOrd; k++){
        value = A->GenArray[i].rValue[localElem][k];

        VecSetValue(vecObj, j*rOrd+k, value, INSERT_VALUES);
      }
    } //else if (A->GenArray[i].iValue != NULL) int value
  }
}

 //-----------------------------------------------------------------------------
// Convert vector xflow group format to Vec Petsc format
//-----------------------------------------------------------------------------
void yk_vector2VecGroup(xf_All *All, xf_VectorGroup *A, Galaxy *pObj,
                        Vec vecObj, Is_it *reduced){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i;                                // Initialization for iteration
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  for (i=0; i<A->nVector; i++)
    yk_vector2Vec(All, A->Vector[i], pObj, vecObj, reduced);
}


void yk_add2VectorScalar(xf_Vector *A, double randomV){
  int i, j, n;
  for (n=0; n<A->nArray; n++)
    for (i=0; i< A->GenArray[n].n; i++)
      for (j=0; j<A->GenArray[n].r; j++)
        A->GenArray[n].rValue[i][j] +=randomV;

}

void yk_add2VectorGroupScalar(xf_VectorGroup *A, double randomV){
  int i;
  for (i=0; i<A->nVector; i++)
    yk_add2VectorScalar(A->Vector[i], randomV);
}

void yk_fomBuffer(yk_PrimalSolver *ykflow, Universe equation, Is_it *reduced, \
		  int p, char *nameOfDir){

  int mach= reduced->paramMeshGrid[p*reduced->numParams]*10;
  int alfa = reduced->paramMeshGrid[p*reduced->numParams+1];
  int reynolds = reduced->paramMeshGrid[p*reduced->numParams+2];
  sprintf(nameOfDir, "%s_M_%d_A_%d_Re_%d", equation.nameEqn, mach, \
	  alfa, reynolds);
}

void yk_xflow_totalResidual(yk_PrimalSolver *ykflow, Multiverse *multiquation,
                            Cluster *primal, Vec residual, Mat Jacobian,
                            Is_it *reduced, int timeSolveNum){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int ierr;
  enum xfe_Bool Found;
  yk_Xflow *xflow = (yk_Xflow *) ykflow->solver;
  xf_JacobianMatrix *dRdU;
  xf_VectorGroup *RG = NULL;
  xf_VectorGroup *UGi[2];
  xf_SolverData *SolverData=NULL;
  Galaxy *postTime = NULL;
  Vec primalReducedVec;
  Vec primalFullVec;
  Cluster *temp = (Cluster *) malloc (sizeof(Cluster));
  temp->self = (Galaxy *) malloc (sizeof(Galaxy));
  Universe _equation = multiquation->equation;
  Universe _equationReduced = multiquation->equationReduced;
  //  reduced->hrom = 0;
  //need to go in here and modify it for the hyper reduced case
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  // Set up the State temp value to be used in the Residual
  //--------------------------------------------------------------------------
  //Should probably make this UG_h part more... broad
  xf_Call(xf_FindSimilarVectorGroup(xflow->All, xflow->UG, "state1",
                                     xfe_True, xfe_True, NULL, &UGi[0], NULL));
  xf_Call(xf_FindSimilarVectorGroup(xflow->All, xflow->UG, "state2",
                                     xfe_True, xfe_True, NULL, &UGi[1], NULL));
  xf_Call(xf_FindSimilarVectorGroup(xflow->All, xflow->UG, "RG",
                                    xfe_True, xfe_True, NULL, &RG, NULL));     \
  if (Jacobian != NULL)
    xf_Call(xf_FindJacobianMatrix(xflow->All, xflow->All->DataSet, xflow->UG,
                                  NULL, xfe_True, NULL, NULL, &dRdU, &Found));
  else
    dRdU = NULL;
  //create/allocate SOlverData
  xf_Call(xf_CreateSolverData(xflow->All, &SolverData));
  SolverData->DoProcessResidual = xfe_False; // do not process residual
  SolverData->UseArtificialDt = xfe_False;
  SolverData->c = 0.;
  //---------------------------------------------------------------------------
  //Create a temporary Cluster called temp to save timenode - 1 values
  //---------------------------------------------------------------------------
  //Left side of the element
  if (reduced->hrom == 0){
    postTime = primal->self;
  }else if (reduced->hrom == 1){
    VecCreate(PETSC_COMM_SELF, &primalReducedVec);
    VecSetSizes(primalReducedVec, reduced->nBasisFuncs, reduced->nBasisFuncs);
    VecSetType(primalReducedVec, VECSEQ);

    VecCreate(PETSC_COMM_SELF, &primalFullVec);
    VecSetSizes(primalFullVec, primal->stateFull->systemSize,
                primal->stateFull->systemSize);
    VecSetType(primalFullVec, VECSEQ);

    primal->stateFull->time.node = primal->self->time.node;
    array2Vec(_equationReduced, primal->reduced, primalReducedVec);
    MatMult(reduced->rOBState, primalReducedVec, primalFullVec);
    vec2Array(_equation, primal->stateFull, primalFullVec);
    postTime = primal->stateFull;
  }
    //remeber that stateFull is same size as self for hrom == 0
  ks_copyUtype(postTime, temp->self);
  copySystem(_equation, postTime, temp->self);
  temp->self->time.node = postTime->time.node - 1;
  strcpy(temp->clusterId, primal->clusterId);
  ks_readSolution(_equation, temp->self, temp->self->time.node);
  yk_array2VectorGroup(UGi[0], temp->self);
  yk_array2VectorGroup(UGi[1], postTime);

  //WAIT I CAN REWRITE THIS BEETER
  //---------------------------------------------------------------------------
  // Residual and Jacobian
  //---------------------------------------------------------------------------
  xf_Call(xf_SetKeyValueReal(xflow->All->Param->KeyValue, "Time",
                             postTime->time.node*postTime->time.dt));
  //Calculate the Spatial Residual
  xf_Call(xf_CalculateResidual(xflow->All, UGi[1], RG, dRdU, SolverData));
  //Temporary calculate for du u(n+1)-u(n) for now.... since eval acting weird
  xf_VectorGroupMultSet(UGi[0], -1.0, xfe_Add, UGi[1]);
  //Calculate the total Unsteady Residual by adding the Mass Matrix Mdu/dt+R
  xf_AddMassMatrixGroup(xflow->All, 1/postTime->time.dt, NULL, UGi[1], RG,
                        dRdU, SolverData);
  //Convert to Petsc Vec format (Residual)
  yk_vector2VecGroup(xflow->All, RG, primal->self, residual, reduced);
  //yk_vector2VecGroup(primalSolverObj, RG, residual, reduced);
  //Convert to Petsc Mat format (Jacobian)
  if (Jacobian != NULL)
    yk_matrix2D2MatGroup(xflow->All, dRdU, primal->self, Jacobian, reduced);
    //---------------------------------------------------------------------------
  // Jacobian
  //---------------------------------------------------------------------------
  xf_Call(xf_DestroySolverData(SolverData));
  destroySystem(_equation, temp->self);
  if (reduced->hrom == 1){
    VecDestroy(&primalReducedVec);
    VecDestroy(&primalFullVec);
  }
  free(temp->self);
  free(temp);
}
//-----------------------------------------------------------------------------
// Convert xflow text file to ykflow state file
//-----------------------------------------------------------------------------
void yk_xfData2Dat(Galaxy *gObj, xf_VectorGroup *UG, char *jobFile){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i,j;                              // Initialization for iteration
  int length;
  int numStates;
  int stateCount = 0;
  int status;
  int count = 0 ;
  int numFiles = gObj->time.count;
  char stateInput[xf_MAXSTRLEN];
  char newoutFile[xf_MAXSTRLEN];
  char outFile[xf_MAXSTRLEN];
  char numFilesString[xf_MAXSTRLEN];
  char dataString[xf_MAXSTRLEN];

  printf("%d bunny \n", gObj->time.count);
  sprintf(stateInput, "%s_U", jobFile);
  sprintf(numFilesString, "%d", numFiles);
  char * argv[] =  {"/Users/yshimiz/xflow/bin/xf_Data2Text", " -inroot ",
                    stateInput, " -batch", " 0 1 ",  numFilesString, NULL};
  char outputS[200];
  char * env[] = {NULL};
  FILE *dataFile;
  FILE *newFile;
  //pid_t pid = fork();
  //---------------------------------------------------------------------------
  // Implementation
  //---------------------------------------------------------------------------
  printf("%s\n", argv[0]);
  sprintf(outputS, "%s", argv[0]);

  for (i=1; i<6; i++)
    strcat(outputS, argv[i]);
  printf("%s\n", outputS);
  numStates = UG->Vector[0]->StateRank;
  system(outputS);
  /* if (pid == -1){ //Error */
  /*   perror("Error"); */
  /* }else if (pid > 0){ //If this is the parent process */
  /*   waitpid(pid, &status, 0); */
  /* }else{ */
  /*   execve(argv[0], argv, env); */
  /*   _exit(EXIT_FAILURE); //Needed incase execve fails */
  /* } */
  for (i=0; i<numFiles+1; i++){
    stateCount = 0;
    for (j=0; j<UG->nVector; j++){
      sprintf(outFile, "%s%d_%s.txt", stateInput, i,
              xfe_VectorRoleName[UG->Type[j]]);
      //Should add yflow->primal_H need to add the coarse grid information
      sprintf(newoutFile, "%s_%d.dat", gObj->id, i);
      dataFile = fopen(outFile, "r");
      newFile = fopen(newoutFile, "w");
      count = 0;

         while ((fgets(dataString, xf_MAXSTRLEN, dataFile))){
        if (dataString[0]!='\n' &&  dataString[0]!='%' && dataString[1]!=' '){
          length = strlen(dataString);
          dataString[length-1] = '\0';
          fprintf(newFile, "%s", dataString);
          //  fprintf(newFile, "\n");
          count ++;
          if (stateCount == numStates-1){
            fprintf(newFile, "\n");
            stateCount = -1;
          }else{
                    fprintf(newFile, " ");}
          stateCount ++;
        }
      }
      fclose(dataFile);
      fclose(newFile);
    }
  }
  //Converts the necessary solutions at particular times from xflow's Data fil
  //e to ykflow's Dat file.
}

void definelocalMeshGrid(int paramNumber, Is_it *reduced, double *testparam,
                         int *count);

void yk_Init(yk_PrimalSolver *ykflow, Multiverse *multiquation, Cluster *fom,
	     Is_it *reduced){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int i;
  int ierr;
  int nTimeStep = 0;
  char newFace[xf_MAXSTRLEN];
  char jobFile[xf_MAXSTRLEN];
  char eqnReduced[xf_MAXSTRLEN];
  char inputFile[xf_MAXSTRLEN];
  char OutputFile[xf_MAXSTRLEN];
  int argcIn = 2;
  char SavePrefix[xf_MAXSTRLEN];
  char *argvIn[] = {"0", "9", NULL};
  yk_Xflow *xflow  = (yk_Xflow *) ykflow->solver;
  fom->self=(Galaxy *) malloc (sizeof(Galaxy));
  ykflow->numElemCol = 4;
  int numParamSet= 1;
  double value;
  int inter;
  int count=0;
  double *testparam;


  //FOR REDUCED ORDER MODELING AND EVERYTHING RELATED WITH YKFLOW (WHAT A NAME)
  //---------------------------------------------------------------------------
  // Define the multiverse/equation parameters EQN/Define jobe file name
  //---------------------------------------------------------------------------
  xf_Call(xf_GetKeyValue(xflow->KeyValueArg, "job", jobFile));
  strcpy(multiquation->equation.nameEqn, jobFile);
  printf("%s\n", multiquation->equation.nameEqn);
  printf("i'm really confused right now\n");
  printf("%d",xflow->UG->Vector[0]->StateRank);
  multiquation->equation.numStates = xflow->UG->Vector[0]->StateRank;
  sprintf(SavePrefix, "%s", jobFile);
  //---------------------------------------------------------------------------
  // Initalize Parameters for hyper reduced order modeling INP
  //---------------------------------------------------------------------------
  //Not sure if I will use an input file or not
  xf_Call(xf_GetKeyValue(xflow->KeyValueArg, "input", inputFile));
  sprintf(newFace, "%s.inp", inputFile);
  argvIn[1] = newFace;
  //Need to convert the xflow parameters into ykflow parameters initU
  initIs_it(reduced);
  read_input(argcIn, argvIn, multiquation->equation, NULL, NULL, reduced);
  //---------------------------------------------------------------------------
  // Reduced mutliquation equation parameters
  //---------------------------------------------------------------------------
  sprintf(eqnReduced, "%s%s", jobFile, "Reduced");
  strcpy(multiquation->equationReduced.nameEqn, eqnReduced);
  multiquation->equationReduced.numStates = reduced->nBasisFuncs;
  //---------------------------------------------------------------------------
  // Define the Cluster properties here
  //---------------------------------------------------------------------------
  initUtype(fom->self);
  fom->self->time_method = 2;
  //---------------------------------------------------------------------------
  // Interpolation and quad points and basis shit
  //---------------------------------------------------------------------------
  fom->self->basis.p = xflow->UG->Vector[0]->Order[0];
  xf_Call(xf_GetKeyValueInt(xflow->All->Param->KeyValue, "nTimeStep",
                            &nTimeStep));
  xf_Call(xf_GetKeyValueReal(xflow->All->Param->KeyValue, "EndTime",
                               &fom->self->time.t_f));
  xf_Call(xf_GetKeyValueReal(xflow->All->Param->KeyValue, "Time",
                             &fom->self->time.t_0));
  fom->self->time.globalT_f = fom->self->time.t_f;
  fom->self->time.globalT_0 = fom->self->time.t_0;

  fom->self->time.dt = (fom->self->time.t_f-fom->self->time.t_0)/nTimeStep;
  fom->self->time.count = nTimeStep+1;
  //---------------------------------------------------------------------------
  //Set the total number of elements FIne
  //---------------------------------------------------------------------------
  fom->self->space.elem.count = 0;
  for (i=0; i<xflow->All->Mesh->nElemGroup; i++)
    fom->self->space.elem.count += xflow->All->Mesh->ElemGroup[i].nElem;
  //Set the number of basis nodes
  fom->self->basis.nodes = (xflow->UG->Vector[0]->GenArray)->r
    /xflow->UG->Vector[0]->StateRank;
  //Set the total number of nodes
  fom->self->space.node.count = fom->self->basis.nodes*
    fom->self->space.elem.count;
  /* //Set the systemSize */
  /* //tehcnically... thisi s wrong........ (Need to think about this part more) */
  fom->self->systemSize = (xflow->UG->Vector[0]->GenArray)->r*
    fom->self->space.elem.count;
  fom->self->index = (PetscInt *) malloc(fom->self->systemSize*
					 sizeof(PetscInt));
  for (i=0; i<fom->self->systemSize; i++)
    fom->self->index[i] = i;
  strcpy(fom->clusterId, "state");
  strcpy(fom->self->utypeId, "state");
  createSystem(multiquation->equation, fom->self);
  //---------------------------------------------------------------------------
  // Parmas create the meshgrid signifying the different data
  //---------------------------------------------------------------------------

  //---------------------------------------------------------------------------
  // Calculate the time average output and concert files
  //---------------------------------------------------------------------------
  /* printf("%d\n", nTimeStep); */
  /* printf("%d underwear \n", fom->self->time.count); */
  for (i=0; i<fom->self->time.count+1; i++){
    sprintf(OutputFile, "%s_U%d.xfa", SavePrefix, i);
    xf_Call(xf_WriteAllBinary(xflow->All, OutputFile));
  }
  //TURN THIS BACK ON LATER
  /* yk_xfData2Dat(fom->self, xflow->UG, SavePrefix); */



  /* yk_uploadStateCalcTimeAverageOutput(ykflow, multiquation, xflow->UG_H, primal_H->self); */
  /* yk_uploadStateCalcTimeAverageOutput(ykflow, multiquation, xflow->UG_h, primal_h->self); */
  /* reduced->actualJbar = primal_H->self->j_bar - primal_h->self->j_bar; */



  //Calculates the total number of parameter sets
  testparam = (double *) malloc (reduced->numParams*sizeof(double));

  /* for (i=0; i<reduced->numParams; i++){ */
  /*   inter= ((reduced->paramsH[i]*10-reduced->paramsL[i]*10)/ */
  /* 	    reduced->dparams[i])/10+1; */
  /*   numParamSet *= inter; */
  /* } */
  reduced->paramMeshGrid =
    (double *) malloc (reduced->numParams*reduced->numParamSet*sizeof(double));
  definelocalMeshGrid(0, reduced, testparam,  &count);
  for (i=0; i<reduced->numParams*reduced->numParamSet; i++)
    printf("velvet %g\n", reduced->paramMeshGrid[i]);
  free(testparam);



}

void definelocalMeshGrid(int paramNumber, Is_it *reduced, double *testparam,
			 int *count){
  int i;
  double value =reduced->paramsL[paramNumber];
  do{
    testparam[paramNumber] = value;
    if (paramNumber==reduced->numParams-1){
      for(i=0; i<reduced->numParams; i++)
      	reduced->paramMeshGrid[(*count)*reduced->numParams+i] =testparam[i];
      (*count)++;
    }
    if (paramNumber <reduced->numParams-1)
      definelocalMeshGrid(paramNumber+1, reduced, testparam, count);
    //return nextvalue;
    value += reduced->dparams[paramNumber];
  }while (value <reduced->paramsH[paramNumber]+reduced->dparams[paramNumber]);
}


  //Calculate the meshgrid for each parameter set


/* void createSampleMesh(yk_PrimalSolver *ykflow, xf_All *sampleAll){ */
/*   int ierr; */
/*   char jobFile[xf_MAXSTRLEN]; */
/*   enum xfe_Bool DoRestart=0; */
/*   yk_Xflow *xflow = (yk_Xflow *) ykflow->solver; */
/*   //--------------------------------------------------------------------------- */
/*   // Find all the job and equation related information */
/*   //--------------------------------------------------------------------------- */
/*   xf_Call(xf_GetKeyValue(xflow->KeyValueArg, "job", jobFile)); */
/*   xf_Call(xf_ReadAllFromJobFile(jobFile, xfe_True, &sampleAll)); */

/*   xf_Mesh *Mesh = sampleAll->Mesh; */
/*   int nnode = 3; */
/*   int k; */
/*   int nElem = 1; */
/*    xf_SolverData *SolverData=NULL; */

/*   xf_VectorGroup *sampleU; */
/*   printf("BEFORE IT HAPPENS\n"); */
/*   printf("SAMPLE THING\n"); */
/*   printf("airfoil\n",  xflow->All->Mesh->nBFaceGroup); */
/*   printf("are you a puppy %d\n", sampleAll->Mesh->nElemGroup); */
/*   printf("group %d\n", sampleAll->Mesh->ElemGroup[0].nElem); */
/*   printf("nodes %d\n", sampleAll->Mesh->ElemGroup[0].nNode); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][0]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][1]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][2]); */

/*    printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[1][0]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[1][1]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[1][2]); */

/*   printf("group 2 %d\n", sampleAll->Mesh->ElemGroup[1].nElem); */
/*   printf("nodes 2 %d\n", sampleAll->Mesh->ElemGroup[1].nNode); */

/*   printf("hrm %d\n", sampleAll->Mesh->nIFace); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].nFace[0]); */
/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][0].Group); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][1].Group); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][2].Group); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][0].Number); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][1].Number); */

/*   printf("dsaf %d\n", sampleAll->Mesh->ElemGroup[0].Face[0][2].Number); */
/*   printf("AFTER IT HAPPENS\n"); */
/*   sampleAll->Mesh->nBFaceGroup=0; */
/*   sampleAll->Mesh->nElemGroup = 1; */
/*   sampleAll->Mesh->ElemGroup[0].nElem = 1; */
/*   ierr = xf_Error(xf_ReAlloc((void **) &Mesh->ElemGroup[0].nFace, nElem, siz\ */
/* eof(int))); */
/*   if (ierr!=xf_OK) return ierr; */
/*   /\* for (elem=0; elem<nElem; elem++) *\/ */
/*   /\*   Mesh->ElemGroup[0].nFace[elem] = nface; *\/ */
/*   Mesh->ElemGroup[0].nNode = nnode; */
/*   /\* ierr = xf_Error(xf_ReVAlloc2((void ***) &Mesh->ElemGroup[0].Face, nElem, *\/ */
/*   /\* 			     Mesh->ElemGroup[0].nFace, sizeof(xf_Face))); *\/ */
/*   if (ierr!=xf_OK) return ierr; */
/*   ierr = xf_Error(xf_ReAlloc2((void ***) &Mesh->ElemGroup[0].Node, nElem, 3, sizeof(int))); */
/*   int elem = 0; */
/*   for (k = 0; k<3; k++) */
/*     Mesh->ElemGroup[0].Node[elem][k] = xflow->All->Mesh->ElemGroup[0].Node[0][k]; */
/*   sampleAll->Mesh->nIFace = 3; */
/*   printf("are you a puppy %d\n", sampleAll->Mesh->nElemGroup); */
/*   printf("group %d\n", sampleAll->Mesh->ElemGroup[0].nElem); */
/*   printf("nodes %d\n", sampleAll->Mesh->ElemGroup[0].nNode); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][0]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][1]); */
/*   printf("gloabal node number %d\n", sampleAll->Mesh->ElemGroup[0].Node[0][2]); */

/*   printf("SIGH %d\n", sampleAll->Mesh->IFace[230].ElemL); */
/*   printf("SIGH %d\n", sampleAll->Mesh->IFace[230].ElemR); */

/*   /\* printf("group 2 %d\n", sampleAll->Mesh->ElemGroup[1].nElem); *\/ */
/*   /\* printf("nodes 2 %d\n", sampleAll->Mesh->ElemGroup[1].nNode); *\/ */
/*     xf_Call(xf_LoadEqnSetLibrary(sampleAll->EqnSet->EqnSetLibrary)); //Equation */
/*   xf_Call(xf_EqnSetRegister(sampleAll->EqnSet)); */
/*   xf_TimeHistData *TimeHistData=NULL; */
/*   char LogOutput[xf_MAXSTRLEN]; */
/*   xf_Call(xf_GetKeyValue(xflow->All->Param->KeyValue, "LogOutput", LogOutput)); */
/*   xf_Call(xf_FindOrCreatePrimalState(sampleAll, DoRestart, NULL, &sampleU)); */
/*   xf_Call(xf_CreateUniformTimeHistData(sampleAll, LogOutput, &TimeHistData)); */


/*   printf("i wonder i wonder\n"); */

/*   xf_Call(xf_CreateSolverData(sampleAll, &SolverData)); */
/*   SolverData->DoProcessResidual = xfe_False; // do not process residual */
/*   SolverData->UseArtificialDt = xfe_False; */
/*   SolverData->c = 0.; */

/*   xf_VectorGroup *RG = NULL; */
/*   printf("I wanna wish u\n"); */

/*   xf_Call(xf_FindSimilarVectorGroup(sampleAll, sampleU, "RG", */
/* 				    xfe_True, xfe_True, NULL, &RG, NULL)); */

/*   printf("feliz\n"); */
/*   xf_Call(xf_CalculateResidual(sampleAll, sampleU, RG, NULL, SolverData)); */
/*   /\* void yk_vector2Vec(xf_All *All, xf_Vector *A, Galaxy *pObj, Vec vecObj,          *\/ */
/*   /\*                  Is_it *reduced) *\/ */

/*   getchar(); */




/* } */


int yk_forwardSimulation(yk_Xflow *xflow){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  int ierr;
  int nTimeStep, nTimeStep0, UW;
  real Time0;
  enum xfe_Bool DoRestart;
  char jobFile[xf_MAXSTRLEN];
  char SavePrefix[xf_MAXSTRLEN];    // prefix for saving files
  char LogOutput[xf_MAXSTRLEN];
  xf_TimeHistData *TimeHistData=NULL;
  xf_All *sampleAll;
  //---------------------------------------------------------------------------
  // Find all the job and equation related information
  //---------------------------------------------------------------------------
  xf_Call(xf_GetKeyValue(xflow->KeyValueArg, "job", jobFile));
  xf_Call(xf_ReadAllFromJobFile(jobFile, xfe_True, &xflow->All));
  xf_Call(xf_LoadEqnSetLibrary(xflow->All->EqnSet->EqnSetLibrary)); //Equation
  xf_Call(xf_EqnSetRegister(xflow->All->EqnSet));
  //Primal State (DOUBLE CHECK THIS PART)
  //---------------------------------------------------------------------------
  // Burn Time to find the new initial conditions
  //---------------------------------------------------------------------------
  // Get the initial condiitons defined in the equations file
  xf_Call(xf_GetKeyValueBool(xflow->All->Param->KeyValue, "Restart",
                             &DoRestart));
  xf_Call(xf_GetKeyValueReal(xflow->All->Param->KeyValue, "Time", &Time0));
  xf_Call(xf_GetKeyValue(xflow->All->Param->KeyValue, "SavePrefix", SavePrefix));
  xf_Call(xf_GetKeyValue(xflow->All->Param->KeyValue, "LogOutput", LogOutput));
  printf("%s push push\n", LogOutput);
  xf_Call(xf_FindOrCreatePrimalState(xflow->All, DoRestart, NULL, &xflow->UG));
  /* // Create the Time History */
  xf_Call(xf_CreateUniformTimeHistData(xflow->All, LogOutput, &TimeHistData));

  /* xf_Call(xf_SetKeyValueInt(xflow->All->Param->KeyValue, */
  /*                           "UnsteadyWriteInterval", 1)); */
  /* // Run the coarse primal solution */
  /* xf_Call(xf_ApplyTimeScheme(xflow->All, SavePrefix ,xfe_False, &xflow->UG, */
  /*                            TimeHistData)); */
  xf_Call(xf_SetKeyValueReal(xflow->All->Param->KeyValue, "Time", Time0));

  //---------------------------------------------------------------------------
  // Destroy and Free anything tht should be dealt with
  //---------------------------------------------------------------------------
  xf_Call(xf_DestroyTimeHistData(TimeHistData));

  return ierr;
}

void yk_print2xflowTxt(yk_PrimalSolver *ykflow, Multiverse *multiquation,
		       Galaxy *sol){
  int i;
  int ierr;
  yk_Xflow *xflow = (yk_Xflow *) ykflow->solver;
  xf_VectorGroup *UG_approx;\
  enum xfe_Bool DoRestart;
  xf_DataSet *DataSet = NULL;
  char Title[xf_MAXSTRLEN];
  char SavePrefix[xf_MAXSTRLEN];
  char temp[xf_MAXSTRLEN];
  char OutputFile[xf_MAXSTRLEN];
  //---------------------------------------------------------------------------
  //
  //---------------------------------------------------------------------------
  xf_Call(xf_GetKeyValue(xflow->All->Param->KeyValue, "SavePrefix",
			 SavePrefix));
  xf_Call(xf_CreateDataSet(&DataSet));
  xf_Call(xf_DataSetAdd(DataSet, "State", xfe_VectorGroup, xfe_True, (void *)
			xflow->UG, NULL));
  sprintf(temp, "%s_ROM_Approximate_U", SavePrefix);
  printf("%s\n", temp);
  for (i=0; i<sol->time.count+1; i++){
    ks_readSolution(multiquation->equation, sol, i);
    yk_array2VectorGroup(xflow->UG, sol);
    sprintf(Title, "%s%d.data", temp, i);
    xf_Call(xf_WriteDataSetBinary(xflow->All->Mesh, DataSet, NULL, Title));
    sprintf(OutputFile, "%s%d.xfa", temp, i);
    xf_Call(xf_WriteAllBinary(xflow->All, OutputFile));

  }

  sprintf(temp, "%s_ROM_Approximate", SavePrefix);
  yk_xfData2Dat(sol, xflow->UG, temp);
}

void yk_RunErrorEstChaos(yk_PrimalSolver *ykflow, Multiverse *multiquation,
                         Cluster *fom, Cluster *rom, Cluster *hrom,
                         char *argv[], Is_it *reduced){
  //------------------------------------//-------------------------------------
  // Variables here                     // Comments section
  //------------------------------------//-------------------------------------
  //check this and init about this
  yk_Xflow *xflow  = (yk_Xflow *) ykflow->solver;
  /* //--------------------------------------------------------------------------- */
  /* // Reduced Order Modeling */
  /* //--------------------------------------------------------------------------- */
  /* printf("----------------------------------------------------------------\n"); */
  /* printf("|                    Reduced-Order Modeling                    |\n"); */
  /* printf("----------------------------------------------------------------\n"); */
  /* yk_createReducedOrderModel(ykflow, multiquation, fom, rom, reduced); */
  /* /\* if (!reduced->restart) *\/ */
  /* /\* yk_runReducedOrderModel(ykflow, multiquation, fom, rom, reduced); *\/ */
  /* /\* yk_print2xflowTxt(ykflow, multiquation, rom->self); *\/ */
  /* //--------------------------------------------------------------------------- */
  /* // Hyper-Reduced Order Modeling */
  /* //--------------------------------------------------------------------------- */
  /* printf("----------------------------------------------------------------\n"); */
  /* printf("|                 Hyper-Reduced-Order Modeling                 |\n"); */
  /* printf("----------------------------------------------------------------\n"); */
  /* yk_createHyperReducedOrderModel(ykflow, multiquation, fom, hrom, reduced); */
  /* yk_runHyperReducedOrderModel(ykflow, multiquation, fom, hrom, reduced); */
  //---------------------------------------------------------------------------
  // Space-Time Reduced-Order Modeling
  //---------------------------------------------------------------------------
  printf("----------------------------------------------------------------\n");
  printf("|          Space-Time Hyper-Reduced-Order Modeling             |\n");
  printf("----------------------------------------------------------------\n");
  yk_createReducedOrderModel_ST(ykflow, multiquation, fom, rom, reduced);
  yk_runReducedOrderModel_ST(ykflow, multiquation, fom, rom, reduced);
}

int main(int argc, char *argv[]){
  //  static char help[] = "Simple PETSc program";
  // PetscErrorCode ierr;
  ierr = PetscInitialize(&argc, &argv, NULL, NULL);CHKERRQ(ierr);
  //ierr = PetscPr
  //intf(PETSC_COMM_WORLD, "Hello World!\n");CHKERRQ(ierr); ierr = PetscFinalize();
  int *check = (int *) malloc (4*sizeof(int));
  //PetscInitialize(&argc, &argv, NULL, NULL);
  //printf("HELLO\n");
  PetscFinalize();   
//------------------------------------//-------------------------------------
  //Variables here                     // Comments section
  //------------------------------------//-------------------------------------
 /*  static char help[] = "Reads a PETSc matrix and vector from a file and reorders it"; */
 /*  int ierr; */
 /*  int myRank, nProc; */
 /*  char *ArgIn[] = {"job", "NULL", ".job file name to read (run parameters)", */
 /*                   "input", "NULL", ".inp file name to read (run ROM params)", */
 /*                   "nWindow", "10", "starting number of time windows", */
 /*                   "\0"}; */
 /*  Multiverse *multiquation = (Multiverse *) malloc (sizeof(Multiverse)); */
 /*  Cluster *rom = (Cluster *) malloc (sizeof(Cluster)); */
 /*  Cluster *fom = (Cluster *) malloc (sizeof(Cluster)); */
 /*  Cluster *hrom = (Cluster *) malloc (sizeof(Cluster)); */
 /*  Is_it *reduced =(Is_it*) malloc (sizeof(Is_it)); */
 /*  printf("HELLO\n"); */
 /*  yk_PrimalSolver *ykflow = new_Xflow(); */
 /*  yk_Xflow *xflow = (yk_Xflow *) ykflow->solver;  //polymorphism */
 /* /\*  //--------------------------------------------------------------------------- *\/ */
 /* /\*  // Intialize everything related to the xflow stuff *\/ */
 /* /\*  //--------------------------------------------------------------------------- *\/ */
 /*  PetscInitialize(&argc,&argv,(char*)0,help);if (ierr) return ierr; */
  /* SlepcInitialize(&argc, &argv, NULL, NULL); */
  /*  PetscViewerPushFormat(PETSC_VIEWER_STDOUT_SELF, PETSC_VIEWER_ASCII_MATLAB); */

 /*  /\* Initialize parallel-run (no effect in serial) *\/ */
 /*  xf_Call(xf_MPI_Init(&argc, &argv)); */
 /*  /\* /\\* Determine myRank*\\/ *\/ */
 /*  xf_Call(xf_MPI_GetRank(&myRank, &nProc)); */
 /*  // initialize key-value */
 /*  xf_Call(xf_CreateKeyValue(&xflow->KeyValueArg)); */
 /*  /\* // parse arguments *\/ */
 /*  ierr = xf_ParseArg(ArgIn, argc, argv, xflow->KeyValueArg); */
 /* /\* if (ierr == xf_FORCE_QUIT) return xf_OK; *\/ */
 /*  /\* if (ierr != xf_OK) return xf_Error(ierr); *\/ */
 /*  //--------------------------------------------------------------------------- */
 /*  // Search for Attractor/Trajectory Burn Time using xflow only */
 /*  //--------------------------------------------------------------------------- */
 /*  yk_forwardSimulation(xflow); */
 /*  printf("paris\n"); */
 /*  yk_Init(ykflow, multiquation, fom, reduced); */
 /*  /\* yk_RunErrorEstChaos(ykflow, multiquation, fom, rom, hrom, argv, reduced); *\/ */
 /*  //--------------------------------------------------------------------------- */
 /*  // Destroy everything */
 /*  //--------------------------------------------------------------------------- */
 /*  destroySystem(multiquation->equation, fom->self); */

 /*  //  free(reduced->numParams); */

 /*  free(fom->self->index); */
 /*  free(fom->self); */

 /*  xf_Call(xf_DestroyVectorGroup(xflow->UG, xfe_True, xfe_True)); */
 /*  xf_CloseEqnSetLibrary(&xflow->All); */
 /*  xf_Call(xf_DestroyAll(xflow->All)); */

 /*  xf_Call(xf_DestroyKeyValue(xflow->KeyValueArg)); */
 /*  /\* free(rom->self); *\/ */
 /*  free(reduced->params); */
 /*  /\* free(reduced->numParams); *\/ */
 /*  free(reduced->paramsL); */
 /*  free(reduced->paramsH); */
 /*  free(reduced->dparams); */
 /*  free(reduced->paramMeshGrid); */
  /* free(reduced); */
  /* free(rom); */
  /* free(fom); */
  /* free(hrom); */
  /* free(multiquation); */
  /* /\* SlepcFinalize(); *\/ */
  
  /* delete_Xflow(ykflow); */  
  return 0;
}
